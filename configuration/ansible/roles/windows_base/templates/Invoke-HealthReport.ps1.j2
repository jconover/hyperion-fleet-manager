#Requires -Version 5.1
<#
.SYNOPSIS
    Generates health report for Hyperion Fleet Manager
.DESCRIPTION
    This script collects system health metrics and generates a report.
    Executed as a scheduled task every {{ windows_health_report_interval_minutes }} minutes.
    Generated by Ansible windows_base role v{{ _windows_base_role_version }}
.NOTES
    Generated: {{ ansible_date_time.iso8601 }}
    Target Host: {{ inventory_hostname }}
#>

[CmdletBinding()]
param(
    [string]$OutputPath = "{{ windows_health_report_output_path }}",
    [switch]$JSONOutput
)

$ErrorActionPreference = 'Continue'

# Configuration
$Config = @{
    ReportPath = $OutputPath
    Hostname = $env:COMPUTERNAME
    Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    TimestampFile = Get-Date -Format 'yyyyMMdd_HHmmss'
}

function Get-SystemInfo {
    $os = Get-CimInstance -ClassName Win32_OperatingSystem
    $cs = Get-CimInstance -ClassName Win32_ComputerSystem

    return @{
        Hostname = $Config.Hostname
        OSName = $os.Caption
        OSVersion = $os.Version
        OSBuild = $os.BuildNumber
        Architecture = $os.OSArchitecture
        Manufacturer = $cs.Manufacturer
        Model = $cs.Model
        Domain = $cs.Domain
        LastBoot = $os.LastBootUpTime
        Uptime = (Get-Date) - $os.LastBootUpTime
    }
}

function Get-CPUMetrics {
    $cpu = Get-CimInstance -ClassName Win32_Processor | Select-Object -First 1
    $cpuLoad = (Get-Counter '\Processor(_Total)\% Processor Time').CounterSamples.CookedValue

    return @{
        Name = $cpu.Name
        Cores = $cpu.NumberOfCores
        LogicalProcessors = $cpu.NumberOfLogicalProcessors
        MaxClockSpeed = $cpu.MaxClockSpeed
        CurrentLoad = [math]::Round($cpuLoad, 2)
        Status = if ($cpuLoad -lt 80) { 'OK' } elseif ($cpuLoad -lt 95) { 'WARNING' } else { 'CRITICAL' }
    }
}

function Get-MemoryMetrics {
    $os = Get-CimInstance -ClassName Win32_OperatingSystem
    $totalMemoryGB = [math]::Round($os.TotalVisibleMemorySize / 1MB, 2)
    $freeMemoryGB = [math]::Round($os.FreePhysicalMemory / 1MB, 2)
    $usedMemoryGB = $totalMemoryGB - $freeMemoryGB
    $percentUsed = [math]::Round(($usedMemoryGB / $totalMemoryGB) * 100, 2)

    return @{
        TotalGB = $totalMemoryGB
        UsedGB = $usedMemoryGB
        FreeGB = $freeMemoryGB
        PercentUsed = $percentUsed
        Status = if ($percentUsed -lt 80) { 'OK' } elseif ($percentUsed -lt 95) { 'WARNING' } else { 'CRITICAL' }
    }
}

function Get-DiskMetrics {
    $disks = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DriveType=3"
    $diskMetrics = @()

    foreach ($disk in $disks) {
        $totalGB = [math]::Round($disk.Size / 1GB, 2)
        $freeGB = [math]::Round($disk.FreeSpace / 1GB, 2)
        $usedGB = $totalGB - $freeGB
        $percentUsed = if ($totalGB -gt 0) { [math]::Round(($usedGB / $totalGB) * 100, 2) } else { 0 }

        $diskMetrics += @{
            Drive = $disk.DeviceID
            Label = $disk.VolumeName
            TotalGB = $totalGB
            UsedGB = $usedGB
            FreeGB = $freeGB
            PercentUsed = $percentUsed
            Status = if ($percentUsed -lt 80) { 'OK' } elseif ($percentUsed -lt 95) { 'WARNING' } else { 'CRITICAL' }
        }
    }

    return $diskMetrics
}

function Get-NetworkMetrics {
    $adapters = Get-NetAdapter | Where-Object { $_.Status -eq 'Up' }
    $networkMetrics = @()

    foreach ($adapter in $adapters) {
        $ipConfig = Get-NetIPAddress -InterfaceIndex $adapter.ifIndex -AddressFamily IPv4 -ErrorAction SilentlyContinue

        $networkMetrics += @{
            Name = $adapter.Name
            Description = $adapter.InterfaceDescription
            Status = $adapter.Status
            LinkSpeed = $adapter.LinkSpeed
            IPAddress = $ipConfig.IPAddress
            MacAddress = $adapter.MacAddress
        }
    }

    return $networkMetrics
}

function Get-ServiceMetrics {
    $criticalServices = @(
        'WinRM',
        'SNMP',
        'W32Time',
        'Dnscache',
        'EventLog',
        'MpsSvc'
    )

    $serviceMetrics = @()

    foreach ($serviceName in $criticalServices) {
        $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
        if ($service) {
            $serviceMetrics += @{
                Name = $service.Name
                DisplayName = $service.DisplayName
                Status = $service.Status.ToString()
                StartType = $service.StartType.ToString()
                IsHealthy = $service.Status -eq 'Running'
            }
        }
    }

    return $serviceMetrics
}

function Get-EventLogSummary {
    $logSummary = @()
    $cutoffTime = (Get-Date).AddHours(-24)

    $logs = @('Application', 'System', 'Security')

    foreach ($logName in $logs) {
        try {
            $errors = (Get-WinEvent -FilterHashtable @{
                LogName = $logName
                Level = 2  # Error
                StartTime = $cutoffTime
            } -ErrorAction SilentlyContinue | Measure-Object).Count

            $warnings = (Get-WinEvent -FilterHashtable @{
                LogName = $logName
                Level = 3  # Warning
                StartTime = $cutoffTime
            } -ErrorAction SilentlyContinue | Measure-Object).Count

            $logSummary += @{
                LogName = $logName
                ErrorsLast24h = $errors
                WarningsLast24h = $warnings
                Status = if ($errors -eq 0) { 'OK' } elseif ($errors -lt 10) { 'WARNING' } else { 'CRITICAL' }
            }
        } catch {
            $logSummary += @{
                LogName = $logName
                ErrorsLast24h = -1
                WarningsLast24h = -1
                Status = 'UNKNOWN'
            }
        }
    }

    return $logSummary
}

function Get-WindowsUpdateStatus {
    try {
        $updateSession = New-Object -ComObject Microsoft.Update.Session
        $updateSearcher = $updateSession.CreateUpdateSearcher()

        $pendingUpdates = $updateSearcher.Search("IsInstalled=0 and Type='Software'")
        $criticalCount = ($pendingUpdates.Updates | Where-Object { $_.MsrcSeverity -eq 'Critical' }).Count

        return @{
            PendingUpdates = $pendingUpdates.Updates.Count
            CriticalUpdates = $criticalCount
            LastSearchTime = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
            Status = if ($criticalCount -gt 0) { 'CRITICAL' } elseif ($pendingUpdates.Updates.Count -gt 0) { 'WARNING' } else { 'OK' }
        }
    } catch {
        return @{
            PendingUpdates = -1
            CriticalUpdates = -1
            LastSearchTime = $null
            Status = 'UNKNOWN'
            Error = $_.Exception.Message
        }
    }
}

function Get-OverallHealth {
    param($Report)

    $criticalCount = 0
    $warningCount = 0

    # Check CPU
    if ($Report.CPU.Status -eq 'CRITICAL') { $criticalCount++ }
    elseif ($Report.CPU.Status -eq 'WARNING') { $warningCount++ }

    # Check Memory
    if ($Report.Memory.Status -eq 'CRITICAL') { $criticalCount++ }
    elseif ($Report.Memory.Status -eq 'WARNING') { $warningCount++ }

    # Check Disks
    foreach ($disk in $Report.Disks) {
        if ($disk.Status -eq 'CRITICAL') { $criticalCount++ }
        elseif ($disk.Status -eq 'WARNING') { $warningCount++ }
    }

    # Check Services
    $unhealthyServices = ($Report.Services | Where-Object { -not $_.IsHealthy }).Count
    if ($unhealthyServices -gt 0) { $criticalCount++ }

    # Check Event Logs
    foreach ($log in $Report.EventLogs) {
        if ($log.Status -eq 'CRITICAL') { $criticalCount++ }
        elseif ($log.Status -eq 'WARNING') { $warningCount++ }
    }

    # Determine overall status
    if ($criticalCount -gt 0) { return 'CRITICAL' }
    elseif ($warningCount -gt 0) { return 'WARNING' }
    else { return 'OK' }
}

# Main execution
try {
    Write-Host "Generating health report for $($Config.Hostname)..."

    # Collect all metrics
    $report = @{
        Metadata = @{
            GeneratedAt = $Config.Timestamp
            Hostname = $Config.Hostname
            ReportVersion = '{{ _windows_base_role_version }}'
            AnsibleManaged = $true
        }
        System = Get-SystemInfo
        CPU = Get-CPUMetrics
        Memory = Get-MemoryMetrics
        Disks = Get-DiskMetrics
        Network = Get-NetworkMetrics
        Services = Get-ServiceMetrics
        EventLogs = Get-EventLogSummary
        WindowsUpdate = Get-WindowsUpdateStatus
    }

    # Calculate overall health
    $report.OverallHealth = Get-OverallHealth -Report $report

    # Ensure output directory exists
    if (-not (Test-Path $Config.ReportPath)) {
        New-Item -Path $Config.ReportPath -ItemType Directory -Force | Out-Null
    }

    # Save reports
    $jsonPath = Join-Path $Config.ReportPath "health_report_$($Config.TimestampFile).json"
    $latestPath = Join-Path $Config.ReportPath "health_report_latest.json"

    $report | ConvertTo-Json -Depth 10 | Set-Content -Path $jsonPath
    $report | ConvertTo-Json -Depth 10 | Set-Content -Path $latestPath

    # Log to Hyperion event log
    $eventMessage = "Health Report Generated - Status: $($report.OverallHealth)"
    Write-EventLog -LogName 'Application' -Source 'Application' -EventId 1000 -EntryType Information -Message $eventMessage -ErrorAction SilentlyContinue

    # Cleanup old reports (keep last 7 days)
    $cutoffDate = (Get-Date).AddDays(-7)
    Get-ChildItem -Path $Config.ReportPath -Filter "health_report_*.json" |
        Where-Object { $_.Name -ne "health_report_latest.json" -and $_.LastWriteTime -lt $cutoffDate } |
        Remove-Item -Force

    Write-Host "Health report generated: $jsonPath"
    Write-Host "Overall Health Status: $($report.OverallHealth)"

    if ($JSONOutput) {
        return $report | ConvertTo-Json -Depth 10
    }

    return $report

} catch {
    $errorMessage = "Health report generation failed: $($_.Exception.Message)"
    Write-Error $errorMessage
    Write-EventLog -LogName 'Application' -Source 'Application' -EventId 1001 -EntryType Error -Message $errorMessage -ErrorAction SilentlyContinue
    throw
}
