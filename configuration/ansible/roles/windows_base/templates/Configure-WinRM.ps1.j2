#Requires -Version 5.1
#Requires -RunAsAdministrator
<#
.SYNOPSIS
    Configures WinRM for Hyperion Fleet Manager
.DESCRIPTION
    This script configures WinRM settings for secure Ansible communication.
    Generated by Ansible windows_base role v{{ _windows_base_role_version }}
.NOTES
    Generated: {{ ansible_date_time.iso8601 }}
    Target Host: {{ inventory_hostname }}
#>

[CmdletBinding()]
param(
    [switch]$Force,
    [switch]$EnableHTTPS,
    [switch]$DisableHTTP
)

$ErrorActionPreference = 'Stop'

# Configuration values from Ansible
$Config = @{
    MaxMemoryPerShellMB = {{ winrm_max_memory_per_shell_mb }}
    MaxProcessesPerShell = {{ winrm_max_processes_per_shell }}
    MaxShellsPerUser = {{ winrm_max_shells_per_user }}
    IdleTimeoutMs = {{ winrm_idle_timeout_ms }}
    AllowUnencrypted = ${{ 'true' if winrm_allow_unencrypted else 'false' }}
    HTTPSPort = {{ winrm_https_port }}
    HTTPPort = {{ winrm_http_port }}
    CertValidityDays = {{ winrm_cert_validity_days }}
    CertSubject = "{{ winrm_cert_subject }}"
}

function Write-Log {
    param([string]$Message, [string]$Level = 'INFO')
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    $logMessage = "[$timestamp] [$Level] $Message"
    Write-Host $logMessage
    Add-Content -Path "{{ hyperion_base_directory }}\Logs\winrm_config.log" -Value $logMessage -ErrorAction SilentlyContinue
}

function Test-WinRMService {
    $service = Get-Service -Name WinRM -ErrorAction SilentlyContinue
    if (-not $service) {
        Write-Log "WinRM service not found" -Level 'ERROR'
        return $false
    }
    return $service.Status -eq 'Running'
}

function Enable-WinRMService {
    Write-Log "Enabling WinRM service..."

    Set-Service -Name WinRM -StartupType Automatic
    Start-Service -Name WinRM

    # Run quickconfig silently
    winrm quickconfig -quiet 2>&1 | Out-Null

    Write-Log "WinRM service enabled and started"
}

function Set-WinRMConfiguration {
    Write-Log "Configuring WinRM settings..."

    # Configure shell settings
    Set-Item WSMan:\localhost\Shell\MaxMemoryPerShellMB $Config.MaxMemoryPerShellMB
    Set-Item WSMan:\localhost\Shell\MaxProcessesPerShell $Config.MaxProcessesPerShell
    Set-Item WSMan:\localhost\Shell\MaxShellsPerUser $Config.MaxShellsPerUser
    Set-Item WSMan:\localhost\Shell\IdleTimeout $Config.IdleTimeoutMs

    # Configure service settings
    Set-Item WSMan:\localhost\Service\AllowUnencrypted $Config.AllowUnencrypted

    # Configure authentication
    Set-Item WSMan:\localhost\Service\Auth\Basic $true
    Set-Item WSMan:\localhost\Service\Auth\CredSSP $true
    Set-Item WSMan:\localhost\Service\Auth\Negotiate $true
    Set-Item WSMan:\localhost\Service\Auth\Kerberos $true

    Write-Log "WinRM settings configured"
}

function New-WinRMCertificate {
    Write-Log "Creating self-signed certificate for WinRM HTTPS..."

    $hostname = $env:COMPUTERNAME
    $fqdn = [System.Net.Dns]::GetHostByName($hostname).HostName

    $certParams = @{
        Subject = $Config.CertSubject
        DnsName = @($hostname, $fqdn, 'localhost')
        CertStoreLocation = 'Cert:\LocalMachine\My'
        KeyExportPolicy = 'Exportable'
        KeySpec = 'KeyExchange'
        KeyLength = 2048
        KeyUsage = 'KeyEncipherment'
        NotAfter = (Get-Date).AddDays($Config.CertValidityDays)
        FriendlyName = '{{ _winrm_cert_friendly_name }}'
    }

    $cert = New-SelfSignedCertificate @certParams
    Write-Log "Certificate created: $($cert.Thumbprint)"

    return $cert
}

function Set-WinRMHTTPSListener {
    param([string]$Thumbprint)

    Write-Log "Configuring WinRM HTTPS listener..."

    # Remove existing HTTPS listener
    $existingListener = Get-WSManInstance -ResourceURI winrm/config/Listener -Enumerate |
        Where-Object { $_.Transport -eq 'HTTPS' }

    if ($existingListener) {
        Remove-WSManInstance -ResourceURI winrm/config/Listener -SelectorSet @{
            Address = '*'
            Transport = 'HTTPS'
        } -ErrorAction SilentlyContinue
        Write-Log "Removed existing HTTPS listener"
    }

    # Create new HTTPS listener
    New-WSManInstance -ResourceURI winrm/config/Listener -SelectorSet @{
        Address = '*'
        Transport = 'HTTPS'
    } -ValueSet @{
        CertificateThumbprint = $Thumbprint
        Port = $Config.HTTPSPort
    }

    Write-Log "HTTPS listener configured on port $($Config.HTTPSPort)"
}

function Remove-WinRMHTTPListener {
    Write-Log "Removing WinRM HTTP listener..."

    $httpListener = Get-WSManInstance -ResourceURI winrm/config/Listener -Enumerate |
        Where-Object { $_.Transport -eq 'HTTP' }

    if ($httpListener) {
        Remove-WSManInstance -ResourceURI winrm/config/Listener -SelectorSet @{
            Address = '*'
            Transport = 'HTTP'
        }
        Write-Log "HTTP listener removed"
    } else {
        Write-Log "HTTP listener not present"
    }
}

function Set-WinRMFirewallRules {
    Write-Log "Configuring firewall rules for WinRM..."

    # HTTPS rule
    $httpsRule = Get-NetFirewallRule -Name 'WINRM-HTTPS-In-TCP' -ErrorAction SilentlyContinue
    if (-not $httpsRule) {
        New-NetFirewallRule -Name 'WINRM-HTTPS-In-TCP' `
            -DisplayName 'Windows Remote Management (HTTPS-In)' `
            -Direction Inbound `
            -Protocol TCP `
            -LocalPort $Config.HTTPSPort `
            -Action Allow `
            -Profile Domain,Private,Public `
            -Enabled True
        Write-Log "Created HTTPS firewall rule"
    }

    Write-Log "Firewall rules configured"
}

function Test-WinRMConfiguration {
    Write-Log "Testing WinRM configuration..."

    $results = @{
        ServiceRunning = Test-WinRMService
        HTTPSListener = $false
        HTTPListener = $false
        Configuration = $false
    }

    # Check listeners
    $listeners = Get-WSManInstance -ResourceURI winrm/config/Listener -Enumerate
    $results.HTTPSListener = ($listeners | Where-Object { $_.Transport -eq 'HTTPS' }) -ne $null
    $results.HTTPListener = ($listeners | Where-Object { $_.Transport -eq 'HTTP' }) -ne $null

    # Verify configuration
    try {
        $shell = Get-Item WSMan:\localhost\Shell
        $results.Configuration = $true
    } catch {
        $results.Configuration = $false
    }

    Write-Log "Test Results:"
    Write-Log "  Service Running: $($results.ServiceRunning)"
    Write-Log "  HTTPS Listener: $($results.HTTPSListener)"
    Write-Log "  HTTP Listener: $($results.HTTPListener)"
    Write-Log "  Configuration Valid: $($results.Configuration)"

    return $results
}

# Main execution
try {
    Write-Log "=== WinRM Configuration Script Started ==="
    Write-Log "Host: {{ inventory_hostname }}"

    # Ensure WinRM is running
    if (-not (Test-WinRMService)) {
        Enable-WinRMService
    }

    # Apply base configuration
    Set-WinRMConfiguration

    # Configure HTTPS if requested
    if ($EnableHTTPS -or $true) {  # Always enable HTTPS per Ansible config
        # Check for existing valid certificate
        $existingCert = Get-ChildItem -Path Cert:\LocalMachine\My |
            Where-Object { $_.Subject -eq $Config.CertSubject -and $_.NotAfter -gt (Get-Date).AddDays(30) } |
            Sort-Object NotAfter -Descending |
            Select-Object -First 1

        if ($existingCert -and -not $Force) {
            Write-Log "Using existing certificate: $($existingCert.Thumbprint)"
            $certThumbprint = $existingCert.Thumbprint
        } else {
            $cert = New-WinRMCertificate
            $certThumbprint = $cert.Thumbprint
        }

        Set-WinRMHTTPSListener -Thumbprint $certThumbprint
    }

    # Disable HTTP if requested
    if ($DisableHTTP -or (-not {{ 'true' if winrm_enable_http else 'false' }})) {
        Remove-WinRMHTTPListener
    }

    # Configure firewall
    Set-WinRMFirewallRules

    # Restart WinRM to apply changes
    Restart-Service WinRM -Force
    Start-Sleep -Seconds 5

    # Verify configuration
    $testResults = Test-WinRMConfiguration

    Write-Log "=== WinRM Configuration Script Completed ==="

    return $testResults

} catch {
    Write-Log "ERROR: $($_.Exception.Message)" -Level 'ERROR'
    throw
}
